[{"title":"从冒牌天神到软件架构","url":"/2020/10/19/bruce-almighty-and-programming/","content":"十一趁着休息，重温了一遍金凯瑞经典影片《冒牌天神》。可能有点暴露年龄。\n\n电影讲述一位诸事不顺的电视台播报员，他把所有的发生在他身上的衰事全都怪在“上帝”的头上，于是上帝决定出让一个星期的管理权给金·凯瑞，让他也尝尝掌管全世界的感觉。\n\n记得上一次看应该还是在工作之前，这次带着满脑子工作看，倒是看出个有趣的软件工程思维。\n影片中有一个情节是金凯瑞获得了上帝的能力以后，能够听到城里所有人的祷告。按照上帝的指示，他需要回应这些祷告。经过一个不太情愿的过程之后，金凯瑞最终决定着手开始上帝的工作。  \n首先，肯定需要有一个良好的“交互界面”来呈现这些祷告。  \n最初，祷告的声音直接在金凯瑞耳边回响。想象一千只鸭子在你耳边叫。这显然是一个糟糕的交互方式。  \n然后，金凯瑞想到利用便签。一瞬间，便签覆盖了整个房间，盖了一层又一层。包括他的身上也被贴了厚厚一层便签。  \n最后，还得是现代化的手段。他创造了一个祈祷接收程序。有点像电子邮件。  \n\n\n小时候看这段只是觉得好笑。现在回过头来看，这不就是一种软件工程的应用吗？  \n整个“业务”的核心功能就是处理民众的祈祷。耳边的低吟，便签亦或祈祷 App 都是这个业务的交互方式。在核心业务不做任何修改的情况下，任意修改交互，这不就是软件行业的核心业务逻辑和UI分离的实现吗？  \n由此，我联想到前段时间看的一本书。东野圭吾的《沉睡的人鱼之家》。书中讲述了一个小女孩因意外溺水脑死亡后，作为脑机接口研发公司老板的爸爸在不愿相信失去女儿的妈妈驱动下让小女孩又“活了”若干年的故事。书中探讨的一些哲学问题这里暂且不展开。比较吸引我的是对小女孩的神经进行刺激来达到活动身体的目的那段。可能在不久的将来，在没有大脑控制的情况下，人们通过直接发送信号到肌肉也能达到运动的目的。反过来说，大脑发出的运动控制信号可以输入到机械上，帮助残疾人正常生活。正是大自然这种松耦合的设计，才使得这些成为可能。  \n程序员们，你们还想要继续写紧耦合的代码吗？\n","tags":["architecture"]},{"title":"网络延迟和网络延时","url":"/2020/10/13/delay-latency/","content":"在计算机网络开发中，我们经常会遇到两个概念，延迟（delay）和延时（latency）。中文含义的一字之差让我们经常困惑，他们究竟有什么区别？\n是什么延迟（delay）是指网络中的数据从一个端点传输到另一个端点所需的时间，通常以毫秒为单位。延迟受多个因素影响，包括数据包的大小，流量大小等。延时（latency）本质上与延迟紧密相关。有时延时被直接解释为延迟。而更常见的情况是，延时表示往返时间。往返时间包含了发送数据包所需的时间，以及它返回的时间。但并不包括目的地处理数据包所花费的时间。  \n什么导致了延迟延迟主要由四方面原因造成：处理延迟、排队延迟、传输延迟和传播延迟。\n1. 处理延迟是指系统对数据包报头进行分析和确定数据包被发送到哪里去所要花费的时间。这很大程度上取决于路由表中的条目数量、系统中数据结构的执行以及硬件的实现。\n2. 排队延迟是指数据包从进入发送队列到被发送之间经过的时间。这取决于流量大小、流量类型以及具体实现中采用什么路由器队列算法。不同的算法效果不一样，有的可以根据系统参数调整延迟时间，或者对所有流量设定相应的延迟时间。\n3. 传输延迟是指将包中的数据位传入线路所需要的时间。根据数据包的大小和带宽的不同而有所变化。但并不取决于传输线路的距离，因为它仅仅是指将包的数据位传入线路的时间，而不是沿传输线路到达接收端点的时间。\n4. 传播延迟是指数据包的第一个比特位从发送端到达接收端的时间。通常也被称为距离的延迟，受数据传输距离和传播速度的影响。\n延迟的影响延迟的影响主要体现在实时通信的用户体验上。在音视频通话中，当延迟达到150毫秒时，用户体验就将受到影响；当延迟达到400毫秒时，用户能明显感知到延迟存在。不仅如此，延迟还可能造成音视频不同步等问题。\n更近一步基于音视频的实时通信中，通常会连续传输数据包以保持信息实时传播。由于IP网络路由状态频繁变化使得每个数据包分别经由不同的物理路由到达或者节点流量拥塞，数据包在各节点缓存时间过长，使得数据包到达接收端的时间差较大。这种延迟差异被称为抖动。抖动对实时音视频通信来说是相当大的问题。\n","tags":["network"]},{"title":"Project Euler 12: Highly divisible triangular number","url":"/2020/10/11/project-euler-12/","content":"\nThe sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:\n1, 3, 6, 10, 15, 21, 28, 36, 45, 55, …\nLet us list the factors of the first seven triangle numbers: 1: 1 3: 1,3 6: 1,2,3,610: 1,2,5,1015: 1,3,5,1521: 1,3,7,2128: 1,2,4,7,14,28We can see that 28 is the first triangle number to have over five divisors.\nWhat is the value of the first triangle number to have over five hundred divisors?\n\n这题是要计算出最小的拥有500个因数的三角数。三角数即正整数前n项的和：1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78,..n(n+1)/2。  \n想当然三角数的计算不难：  \nfunc GetTriangularNumber(n int) int &#123;\n    return n * (n + 1) / 2\n&#125;\n那么问题就转化为拆解正整数的因数了？  \nfunc ListDivisors(input int) []int &#123;\n    var ret []int\n    for i := 1; i &lt;= input; i++ &#123;\n        if input%i == 0 &#123;\n            ret = append(ret, i)\n        &#125;\n    &#125;\n    return ret\n&#125;\n当然没有那么简单，这种暴力解法即不高效也不优雅。\n正解简单补习一下分解质因数：$$n = \\prod_{i=1}^{k}p_{i}^{a_{i}} =  p_{1}^{a_{1}} · p_{2}^{a_{2}} ······ p_{k}^{a_{k}}$$公式表示 n 可以表示为k个其质因数$p_i$的$a_i$次幂的乘积。这个公式应该不难理解，正整数可以分解为该正整数质因数的乘积，如 12 = 2 * 2 * 3，即 $12 = 2^2 * 3^1$。即在上述公式中，$k=2$，$p_1=2$, $a_1=2$，$p_2=3$, $a_2=1$  \n再补习下正因约个数定理：$$f(n) = \\prod_{i=1}^{k}p_{i}^{a_i} = (a_1 + 1)(a_2 + 1)···(a_k + 1)$$证明：因为 $n = p_1^{a_1} · p_2^{a_2} ····· p_k^{a_k}$，其中 $p_1^{a_1}$ 的因数分别为：$p_1^0$，$p_1^1$ …… $p_1^{a_1}$，共有 $(a_1 + 1)$ 个。同理 $p_2^{a_2}$ 有 $(a_2 + 1)$ 个 …… $p_k^{a_k}$ 有 $(a_k + 1)$ 个。因此，根据乘法定理，n 的因数共有 $(a_1 + 1)(a_2 + 1)···(a_k + 1)$ 个。  \n举例：$12 = 2^2 * 3^1$，其因数为 1, 2, 3, 4, 6, 12。即 $(2 + 1) * (1 + 1) = 6$ 个。\n编码由上可知，这个问题可以转化为求正整数的质因数的个数，以及各个质因数出现的次数。在 Project Euler 之前的问题中，我们已经遇到很多次求解质因数的题目了，可以直接拿过来使用。当然需要做点小小的修改：  \nfunc Tau(num int) int &#123;\n    if num == 1 &#123;\n        return 1\n    &#125;\n    n := num\n    // 从最小的质数开始\n    i := 2\n    // 质因数个数的乘积\n    p := 1\n\n    for i*i &lt; n &#123;\n        c := 1\n        for n%i == 0 &#123;\n            n /= i\n            c++\n        &#125;\n        i++\n        p *= c\n    &#125;\n\n    // 未除尽时，最大质因数为包括在内，需要添加\n    if n == num || n &gt; 1 &#123;\n        p *= 1 + 1\n    &#125;\n\n    return p\n&#125;\n最后在main 函数中调用：  \nfunc main() &#123;\n    n := 1\n    d := 1\n    for Tau(d) &lt;= 500 &#123;\n        n++\n        d += n\n    &#125;\n\n    fmt.Println(&quot;The first triagular number with 500 divisors is&quot;, d)\n&#125;\n后记Project Euler 是很好的 code kata 练习题库，我将坚持以 TDD 的方式刷完所有题目，并记录下一些在此过程中趟过的坑。\n","tags":["poject euler"]},{"title":"当我谈软件工艺时我谈些什么","url":"/2020/09/29/software-craftsmanship-is-about/","content":"\n原文 What Software Craftsmanship is about 是 Robert C. Martin（Uncle Bob）发表在个人博客上的第一篇文章。Uncle Bob 软件工程师，讲师，畅销书作家。他是敏捷宣言的发起人之一，并以开发众多软件设计原理而闻名，如较知名的“SOLID”五项原则。笔者打算本篇开始，搬运并翻译 Uncle Bob 博客上的所有文章，在吸收 Uncle Bob 程序设计思想的同时锻炼自己的英文文献阅读能力（Uncle Bob 的文字中经常夹杂生高（sheng）深（pi）的词汇，以我薄弱的英文阅读能力有时候读起来挺艰难的🤦‍♂️）\n\nTL;DR.\n\n我已经看了Dan North 的博文，还有Gil Zilberfeld的，Michael Feather的，以及Jason Gorman的（笔者注：这些文章都是反对软件研发是一项工艺的观点）。看起来我们的软件工艺运动的理念没有被完全理解。我希望这篇文章能澄清一些事实。\n为什么会有软件工艺运动？是什么带动了他？现在是什么在驱动它？答案只有一个：\n\n我们已经厌倦了写垃圾软件\n\n就是这样。歌声响起，《难忘今宵》，晚会结束。\n我们厌倦了敲打垃圾代码。我们厌倦了因为交付糟糕的软件而导致我们和我们的老板们丢脸。我们厌倦了半夜回复客户重启一下系统试试。我们不希望 Bug 列表有一千页那么长。我们不希望代码一天天变得更加混乱不堪。我们厌倦了搞砸工作。我们想要开始更好地完成工作。\n这。。。就是。。。为什么。没有其他原因。\n我们不会做：\n\n我们不把代码作为一切的中心。\n我们不会闭门造车忽略业务和客户。\n我们不会钻牛角尖。\n我们不再提供廉价的认证。\n我们不会忘记我们工作是为了满足我们的客户。\n\n我们不再做：\n\n我们不再为了赶进度而制造混乱。\n我们不再接受稍后再去整理这样的谎言。\n我们不再相信快速就意味着脏乱。\n我们不再接受选择错误的做法。\n我们不再允许任何人强迫我们做不专业的行为。\n\n我们从现在开始要做：\n\n我们会以快速前进的唯一方法就是保证质量的方式来保证进度。\n我们会以最棒的代码来服务客户。\n我们会以最佳的设计来让我们的雇主以我们为荣。\n我们会以测试一切来让我们的团队以我们为荣。\n我们会以谦卑的态度来先写测试代码。\n我们会不断锻炼我们的技艺以跟进一步。\n\n我们会记住我们的祖辈告诉我们的：\n\n任何值得做的事情都值得做好。\n踏实和稳重是赢得比赛的关键。\n三思而后行。\n练习，练习，练习。\n\n我想有些人可能会对我们的 code kata，code retreat，我们的练习课程产生疑问。他们可能会认为我们在闭门造车，抛弃了我们的客户。他们可能会认为我们放弃了现实世界并屈服于娱乐自己的诱惑。我可以看到他们是怎么得出这个结论的。\n但是他们错了。我们这么做是因为我们在乎客户。我们把时间和精力花在使自己变得更强，以便我们的雇主从我们身上获得最大的价值。\n你觉得音乐家们只在舞台上表演的时候才演奏他们的乐器吗？你觉得击球手只在比赛中才会打球吧？你觉得律师是靠在法庭上完成案件的吗？显然不是！那些人都是专业人士。专业人士会不断练习！专业人士会研究自己学科的细节。专业人士了解所有的小技巧和怪癖。他们知道历史，理论和佚事。他们了解技术和方法。他们知道好的选择和坏的选择，以及如何区分它们。他们之所以了解这些东西就是因为他们练习，练习，练习。\n因此，当你看到带着绿色手环，上面写着“Clean Code（整洁代码）”或者“Test First（测试优先）”或者“Test Obsessed（沉迷测试）”的人，那不意味着他们加入了运动，或者签署了宣言，或者他们以某种方式感觉自己比别人更优越。他们不是圣战参与者。他们不是想加入部落，在篝火旁缩着。绿色手环是个人的事。这是对自己的承诺：“我会做好的。我不会着急。我会编写测试。我会以好为快。我不会写垃圾代码。我会练习，练习，练习，这样我才能成为一个专业人士。”\n","tags":["translation","uncle bob"]},{"title":"Service Mesh","url":"/2020/09/25/service-mesh/","content":"Service Mesh 是服务间通信的基础设施。 Buoyant 公司 CEO William Morgan 在博文《What’s a service mesh? And why do I need one?》中解释了什么是 Service Mesh，以及为什么云原生需要 Service Mesh。\n\nA service mesh is a dedicated infrastructure layer for handling service-to-service communication. It’s responsible for the reliable delivery for requests through the complex topology of services that comprise a modern, cloud native application. In practice, the service mesh is typically implemented as an array of lightweight network proxies that are deployed alongside application code, without the application needing to be aware.\n\nService Mesh 由来自计算机网络诞生至今，我们经历了以下几个阶段：\n\n主机之间直接使用网线相连\n\n\n网络层出现，解耦了网络与应用程序\n\n\n在应用程序内部集成控制流\n\n\n将流控从应用程序分离并加入到网络层（TCP/IP）\n\n\n微服务出现，各个微服务中集成服务发现和断路器\n\n\n出现了专门用于服务发现和断路器的软件包/库（SDK），如 Twitter 的 Finagle 和 Facebook 的 Proxygen。这时候还是需要集成到应用程序内部。\n\n\n出现了专门用于服务发现和断路器的开源软件，如 Netflix OSS、Airbnb 的 synapse 和 nerve。\n\n\n最后作为微服务的中间层 Service Mesh 出现了。\n\n\n理解 Service MeshService Mesh 可以比作是应用程序或者说微服务间的 TCP/IP，负责服务之间的网络调用、限流、熔断和监控。对于编写应用程序来说一般无须关心 TCP/IP 这一层（比如通过 HTTP 协议的 RESTful 应用），同样使用 Service Mesh 也就无须关心服务之间的那些原来是通过应用程序或者其他框架实现的事情，比如 Spring Cloud、OSS，现在只要交给 Service Mesh 就可以了。\nService Mesh 的架构如下图所示：\n\n\n图片来自：Pattern: Service Mesh\nService Mesh 作为 sidecar 运行，对应用程序来说是透明的，所有应用程序间的流量都会通过它，所以对应用程序流量的控制都可以在 Service Mesh 中实现。\n参考What’s a service mesh? And why do I need one?\nService Mesh 服务网格\nPattern: Service Mesh\n","tags":["cloud native"]}]