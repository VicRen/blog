[{"title":"Project Euler 12: Highly divisible triangular number","url":"/2020/10/11/project-euler-12/","content":"\nThe sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:\n1, 3, 6, 10, 15, 21, 28, 36, 45, 55, …\nLet us list the factors of the first seven triangle numbers: 1: 1 3: 1,3 6: 1,2,3,610: 1,2,5,1015: 1,3,5,1521: 1,3,7,2128: 1,2,4,7,14,28We can see that 28 is the first triangle number to have over five divisors.\nWhat is the value of the first triangle number to have over five hundred divisors?\n\n这题是要计算出最小的拥有500个因数的三角数。三角数即正整数前n项的和：1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78,..n(n+1)/2。  \n想当然三角数的计算不难：  \nfunc GetTriangularNumber(n int) int &#123;\n    return n * (n + 1) / 2\n&#125;\n那么问题就转化为拆解正整数的因数了？  \nfunc ListDivisors(input int) []int &#123;\n    var ret []int\n    for i := 1; i &lt;= input; i++ &#123;\n        if input%i == 0 &#123;\n            ret = append(ret, i)\n        &#125;\n    &#125;\n    return ret\n&#125;\n当然没有那么简单，这种暴力解法即不高效也不优雅。\n正解简单补习一下分解质因数：$$n = \\prod_{i=1}^{k}p_{i}^{a_{i}} =  p_{1}^{a_{1}} · p_{2}^{a_{2}} ······ p_{k}^{a_{k}}$$公式表示 n 可以表示为k个其质因数$p_i$的$a_i$次幂的乘积。这个公式应该不难理解，正整数可以分解为该正整数质因数的乘积，如 12 = 2 * 2 * 3，即 $12 = 2^2 * 3^1$。即在上述公式中，$k=2$，$p_1=2$, $a_1=2$，$p_2=3$, $a_2=1$  \n再补习下正因约个数定理：$$f(n) \\prod_{i=1}^{k}p_{i}^{a_i} = (a_1 + 1)(a_2 + 1)···(a_k + 1)$$证明：因为 $n = p_1^{a_1} · p_2^{a_2} ····· p_k^{a_k}$，其中 $p_1^{a_1}$ 的因数分别为：$p_1^0$，$p_1^1$ …… $p_1^{a_1}$，共有 $(a_1 + 1)$ 个。同理 $p_2^{a_2}$ 有 $(a_2 + 1)$ 个 …… $p_k^{a_k}$ 有 $(a_k + 1)$ 个。因此，根据乘法定理，n 的因数共有 $(a_1 + 1)(a_2 + 1)···(a_k + 1)$ 个。  \n举例：$12 = 2^2 * 3^1$，其因数为 1, 2, 3, 4, 6, 12。即 $(2 + 1) * (1 + 1) = 6$ 个。\n编码由上可知，这个问题可以转化为求正整数的质因数的个数，以及各个质因数出现的次数。在 Project Euler 之前的问题中，我们已经遇到很多次求解质因数的题目了，可以直接拿过来使用。当然需要做点小小的修改：  \nfunc Tau(num int) int &#123;\n    if num == 1 &#123;\n        return 1\n    &#125;\n    n := num\n    // 从最小的质数开始\n    i := 2\n    // 质因数个数的乘积\n    p := 1\n\n    for i*i &lt; n &#123;\n        c := 1\n        for n%i == 0 &#123;\n            n /= i\n            c++\n        &#125;\n        i++\n        p *= c\n    &#125;\n\n    // 未除尽时，最大质因数为包括在内，需要添加\n    if n == num || n &gt; 1 &#123;\n        p *= 1 + 1\n    &#125;\n\n    return p\n&#125;\n最后在main 函数中调用：  \nfunc main() &#123;\n    n := 1\n    d := 1\n    for Tau(d) &lt;= 500 &#123;\n        n++\n        d += n\n    &#125;\n\n    fmt.Println(&quot;The first triagular number with 500 divisors is&quot;, d)\n&#125;\n后记Project Euler 是很好的 code kata 练习题库，我将坚持以 TDD 的方式刷完所有题目，并记录下一些在此过程中趟过的坑。\n","tags":["poject euler"]},{"title":"当我谈软件工艺时我谈些什么","url":"/2020/09/29/software-craftsmanship-is-about/","content":"\n原文 What Software Craftsmanship is about 是 Robert C. Martin（Uncle Bob）发表在个人博客上的第一篇文章。Uncle Bob 软件工程师，讲师，畅销书作家。他是敏捷宣言的发起人之一，并以开发众多软件设计原理而闻名，如较知名的“SOLID”五项原则。笔者打算本篇开始，搬运并翻译 Uncle Bob 博客上的所有文章，在吸收 Uncle Bob 程序设计思想的同时锻炼自己的英文文献阅读能力（Uncle Bob 的文字中经常夹杂生高（sheng）深（pi）的词汇，以我薄弱的英文阅读能力有时候读起来挺艰难的🤦‍♂️）\n\nTL;DR.\n\n我已经看了Dan North 的博文，还有Gil Zilberfeld的，Michael Feather的，以及Jason Gorman的（笔者注：这些文章都是反对软件研发是一项工艺的观点）。看起来我们的软件工艺运动的理念没有被完全理解。我希望这篇文章能澄清一些事实。\n为什么会有软件工艺运动？是什么带动了他？现在是什么在驱动它？答案只有一个：\n\n我们已经厌倦了写垃圾软件\n\n就是这样。歌声响起，《难忘今宵》，晚会结束。\n我们厌倦了敲打垃圾代码。我们厌倦了因为交付糟糕的软件而导致我们和我们的老板们丢脸。我们厌倦了半夜回复客户重启一下系统试试。我们不希望 Bug 列表有一千页那么长。我们不希望代码一天天变得更加混乱不堪。我们厌倦了搞砸工作。我们想要开始更好地完成工作。\n这。。。就是。。。为什么。没有其他原因。\n我们不会做：\n\n我们不把代码作为一切的中心。\n我们不会闭门造车忽略业务和客户。\n我们不会钻牛角尖。\n我们不再提供廉价的认证。\n我们不会忘记我们工作是为了满足我们的客户。\n\n我们不再做：\n\n我们不再为了赶进度而制造混乱。\n我们不再接受稍后再去整理这样的谎言。\n我们不再相信快速就意味着脏乱。\n我们不再接受选择错误的做法。\n我们不再允许任何人强迫我们做不专业的行为。\n\n我们从现在开始要做：\n\n我们会以快速前进的唯一方法就是保证质量的方式来保证进度。\n我们会以最棒的代码来服务客户。\n我们会以最佳的设计来让我们的雇主以我们为荣。\n我们会以测试一切来让我们的团队以我们为荣。\n我们会以谦卑的态度来先写测试代码。\n我们会不断锻炼我们的技艺以跟进一步。\n\n我们会记住我们的祖辈告诉我们的：\n\n任何值得做的事情都值得做好。\n踏实和稳重是赢得比赛的关键。\n三思而后行。\n练习，练习，练习。\n\n我想有些人可能会对我们的 code kata，code retreat，我们的练习课程产生疑问。他们可能会认为我们在闭门造车，抛弃了我们的客户。他们可能会认为我们放弃了现实世界并屈服于娱乐自己的诱惑。我可以看到他们是怎么得出这个结论的。\n但是他们错了。我们这么做是因为我们在乎客户。我们把时间和精力花在使自己变得更强，以便我们的雇主从我们身上获得最大的价值。\n你觉得音乐家们只在舞台上表演的时候才演奏他们的乐器吗？你觉得击球手只在比赛中才会打球吧？你觉得律师是靠在法庭上完成案件的吗？显然不是！那些人都是专业人士。专业人士会不断练习！专业人士会研究自己学科的细节。专业人士了解所有的小技巧和怪癖。他们知道历史，理论和佚事。他们了解技术和方法。他们知道好的选择和坏的选择，以及如何区分它们。他们之所以了解这些东西就是因为他们练习，练习，练习。\n因此，当你看到带着绿色手环，上面写着“Clean Code（整洁代码）”或者“Test First（测试优先）”或者“Test Obsessed（沉迷测试）”的人，那不意味着他们加入了运动，或者签署了宣言，或者他们以某种方式感觉自己比别人更优越。他们不是圣战参与者。他们不是想加入部落，在篝火旁缩着。绿色手环是个人的事。这是对自己的承诺：“我会做好的。我不会着急。我会编写测试。我会以好为快。我不会写垃圾代码。我会练习，练习，练习，这样我才能成为一个专业人士。”\n","tags":["translation","uncle bob"]},{"title":"Service Mesh","url":"/2020/09/25/service-mesh/","content":"Service Mesh 是服务间通信的基础设施。 Buoyant 公司 CEO William Morgan 在博文《What’s a service mesh? And why do I need one?》中解释了什么是 Service Mesh，以及为什么云原生需要 Service Mesh。\n\nA service mesh is a dedicated infrastructure layer for handling service-to-service communication. It’s responsible for the reliable delivery for requests through the complex topology of services that comprise a modern, cloud native application. In practice, the service mesh is typically implemented as an array of lightweight network proxies that are deployed alongside application code, without the application needing to be aware.\n\nService Mesh 由来自计算机网络诞生至今，我们经历了以下几个阶段：\n\n主机之间直接使用网线相连\n\n\n网络层出现，解耦了网络与应用程序\n\n\n在应用程序内部集成控制流\n\n\n将流控从应用程序分离并加入到网络层（TCP/IP）\n\n\n微服务出现，各个微服务中集成服务发现和断路器\n\n\n出现了专门用于服务发现和断路器的软件包/库（SDK），如 Twitter 的 Finagle 和 Facebook 的 Proxygen。这时候还是需要集成到应用程序内部。\n\n\n出现了专门用于服务发现和断路器的开源软件，如 Netflix OSS、Airbnb 的 synapse 和 nerve。\n\n\n最后作为微服务的中间层 Service Mesh 出现了。\n\n\n理解 Service MeshService Mesh 可以比作是应用程序或者说微服务间的 TCP/IP，负责服务之间的网络调用、限流、熔断和监控。对于编写应用程序来说一般无须关心 TCP/IP 这一层（比如通过 HTTP 协议的 RESTful 应用），同样使用 Service Mesh 也就无须关心服务之间的那些原来是通过应用程序或者其他框架实现的事情，比如 Spring Cloud、OSS，现在只要交给 Service Mesh 就可以了。\nService Mesh 的架构如下图所示：\n\n\n图片来自：Pattern: Service Mesh\nService Mesh 作为 sidecar 运行，对应用程序来说是透明的，所有应用程序间的流量都会通过它，所以对应用程序流量的控制都可以在 Service Mesh 中实现。\n参考What’s a service mesh? And why do I need one?\nService Mesh 服务网格\nPattern: Service Mesh\n","tags":["cloud native"]}]